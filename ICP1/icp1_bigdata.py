# -*- coding: utf-8 -*-
"""ICP1_BigData.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c82JBDIeKIRi4jsNv_VAokR1Yvzf6JL5
"""

from google.colab import drive
drive.mount('/content/gdrive')

pwd

cd gdrive/My\ Drive

pwd

cd BigData_CS5542/

ls

import pandas as pd
import numpy as np
import random as rnd

# visualization
import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv('./Data.csv')

df.shape

df.head()

##describing data
print(df.columns.values)

"""**Data Cleaning**

Identify the null values if any and replace with zeros
"""

# Remove if any null values if any
modifiedDF=df.fillna(" ")

# verify no longer null values presented in the data
modifiedDF.isnull().sum()

"""**1. Correlation**"""

corr = df.corr()

ax = sns.heatmap(
    corr, 
    vmin=-1, vmax=1, center=0,
    cmap=sns.diverging_palette(20, 220, n=500),
    square=True
)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=90,
    horizontalalignment='left'
);

## since radius and area are proportion relation.
df_modified=df[['radius_mean', 'area_mean']].groupby(['radius_mean'], as_index=False).mean().sort_values(by='area_mean', ascending=False) 
corr = df_modified.corr()
ax = sns.heatmap(
    corr, 
    vmin=-1, vmax=1, center=0,
    cmap=sns.diverging_palette(20, 220, n=500),
    square=True
)

##Analyze by pivoting features ---> with differnt featuers 
df_modified=df[['radius_mean', 'area_mean']].groupby(['radius_mean'], as_index=False).mean().sort_values(by='area_mean', ascending=False)
df_modified=df[['perimeter_mean', 'area_mean']].groupby(['perimeter_mean'], as_index=False).mean().sort_values(by='area_mean', ascending=False)
df_modified=df[['symmetry_se', 'area_mean']].groupby(['symmetry_se'], as_index=False).mean().sort_values(by='area_mean', ascending=False)
df_modified=df[['compactness_se', 'area_mean']].groupby(['compactness_se'], as_index=False).mean().sort_values(by='area_mean', ascending=False)

corr = df_modified.corr()
#ax = sns.heatmap(corr, xticklabels=corr.columns, yticklabels=corr.columns)
ax = sns.heatmap(corr, vmin=-1, vmax=1, center=0, cmap=sns.diverging_palette(20, 220, n=500), square=True)

# Remove if any null values if any
modifiedDF=df.fillna(" ")

# verify no longer null values presented in the data
modifiedDF.isnull().sum()

"""**2. Regression**"""

#Regression 
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# generate random data-set
y = 2 + 3 * modifiedDF['radius_mean'] 
# generate no.of.ranadom values as same as dataset 
x = np.random.rand(569, 1)

# Model initialization
regression_model = LinearRegression()
# Fit the data(train the model)
regression_model.fit(x, y)
# Predict
y_predicted = regression_model.predict(x)

# model evaluation
rmse = mean_squared_error(y, y_predicted)
r2 = r2_score(y, y_predicted)

# printing values
print('Slope:' ,regression_model.coef_)
print('Intercept:', regression_model.intercept_)
print('Root mean squared error: ', rmse)
print('R2 score: ', r2)

# data points
plt.scatter(x, y, s=10)
plt.xlabel('x')
plt.ylabel('y')

# predicted values
plt.plot(x, y_predicted, color='b')
plt.show()

"""**Conclusion**

From the below scatter plot, linear regression model not predicting the data linearly with respect to an input column radius_mean. It means there is no proportionate relation between predicted value (dependent variable) and input value(independent variable).

**3. Mean,Standard Deviation, Sum and Count**
"""

mean1 = modifiedDF['radius_mean'].mean()
std_dev1 = modifiedDF[['radius_mean']].std()
groupby_sum1 = df.groupby(['radius_mean']).sum() 
groupby_count1 = df.groupby(['radius_mean']).count()

print("mean=",mean1)
print("standard_devation=",std_dev1)
print("sum of the group with respect to radius_mean",groupby_sum1)
print("count of the group with respect to radius_mean",groupby_sum1)